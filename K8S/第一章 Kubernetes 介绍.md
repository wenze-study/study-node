# 第一章 Kubernetes 介绍

本章节主要介绍应用程序在服务器上部署方式演变以及 kubernetes 的概念、组件和工作原理。

## 一、应用部署方式演变

在部署应用程序的方式上，主要经历了三个时代：

- **传统部署**：互联网早期，会直接将应用程序部署在物理机上

    > 优点：简单，不需要其他技术的参与
    >
    > 缺点：不能为应用程序定义资源使用边界，很难合理的分配计算资源，而且程序之间容易产生影响。

- **虚拟化部署**：可以在一台物理机上运行多个虚拟机，每个虚拟机都是独立的一个环境

    > 优点：程序环境不会相互产生影响，提供了一定程度的安全性
    >
    > 缺点：增加了操作系统，浪费了部分资源

- 容器化部署：与虚拟化类似，但是共享了操作系统

    > 优点：
    >
    > 1. 可以保证每个容器拥有自己的文件系统、CPU、内存、进程空间等
    > 2. 运行应用程序所需要的资源都被容器包装，并和底层基础架构解耦
    > 3. 容器化的应用程序可以跨云服务商、跨 Linux 操作系统发行版进行部署

![k8s-部署方式的演变](https://study-node-md.oss-cn-beijing.aliyuncs.com/2023%2F09%2F08%2F1694139981-3c53b6a743c72f6d4c5f8e1419828b55-20230908102619.png)

容器化部署方式给我们带来了很多的便利，但是也会出现一些问题，比如说：

- 一个容器故障停机了，怎么样让另外一个容器立刻启动去替补停机的容器
- 当并发访问量变大的时候，怎么样做到横向扩展容器数量

这些容器管理的问题统称为**容器编排**问题，为了解决这些容器编排问题，就产生了一些容器编排的软件：

- **Swarm**：Docker 自己的容器编排工具
- **Mesos**：Apache 的一个资源统一管控的工具，需要和 Marathon 结合使用
- **Kubernetes**：Google 开源的容器编排工具

## 二、Kubernetes 简介

​	Kubernetes，是一个全新的基于容器技术的分布式架构领先方案，是谷歌严格保密十几年的秘密武器——Borg 系统的一个开源版本，于 2014 年 9 月发布第一个版本，2015 年 7 月发布第一个正式版本。

​	Kubernetes 的本质是**一组服务器集群**，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。它的目的就是实现资源管理的自动化，主要提供了如下的主要功能：

- **自我修复**：一旦某一个容器崩溃，能够在 1 秒钟左右迅速启动新的容器
- **弹性伸缩**：可以根据需要，自动对集群中正在运行的容器数量进行调整
- **服务发现**：服务可以通过自动发现的形式找到它所依赖的服务
- **负载均衡**：如果一个服务启动了多个容器，能够自动实现请求的负载均衡
- **版本回退**：如果发现新发布的程序版本有问题，可以立即回退到原来的版本
- **存储编排**：可以根据容器自身的需求自动创建存储卷

![K8S-Kubernetes介绍](https://study-node-md.oss-cn-beijing.aliyuncs.com/2023%2F09%2F08%2F1694156803-0a54aefda1168978117b669c619be94e-20230908150641.png)

## 三、Kubernetes 组件

一个 Kubernetes 集群主要是由**控制节点(master)**、**工作节点(node)**构成，每个节点上都会安装不同的组件。

**master：集群的控制平面，负责集群的决策**

> **ApiServer**：资源操作的唯一入口，接受用户输入的命令，提供认证、授权、API 注册和发现等机制
>
> **Scheduler**：负责集群资源调度，按照预定的调度策略将 Pod 调度到相应的 node 节点上
>
> **ControllerManager**：负责维护集群的状态，比如程序部署安排、故障检测、自动扩展、滚动更新等
>
> **Etcd**：负责存储集群中各种资源对象的信息

**node：集群的数据平面，负责为容器提供运行环境**

> **Kubelet**：负责维护容器的生命周期，即通过控制 docker，来创建、更新、销毁容器
>
> **KubeProxy**：负责提供集群内部的服务发现和负载均衡
>
> **Docker**：负责节点上容器的各种操作

![K8S-Kubernetes组件](https://study-node-md.oss-cn-beijing.aliyuncs.com/2023%2F09%2F08%2F1694165394-161421ed07c7365693fbffdc5949df50-image-20230908172953610.png)

下面，以部署一个 Nginx 服务来说明 Kubernetes 系统各个组件调用关系：

1. 首先要明确，一旦 Kubernetes 环境启动之后，master 和 node 都会将自身的信息存储到 etcd 数据库中

2. 一个 Nginx 服务的安装请求会首先被发送到 master 节点的 apiServer 组件

3.  apiServer 组件会调用 scheduler 组件来决定到底应该把这个服务安装到哪个 node 节点上。

    在此时，它会从 etcd 中读取各个 node 节点的信息，然后按照一定的算法进行选择，并将结果告知 apiServer。

4. apiServer 调用 controller-manager 去调度 Node 节点安装 nginx 服务

5. kubelet 接收到指令后，会通知 docker，然后由docker 来启动一个 nginx 的 pod

    pod 是 kubernetes 的最小操作单元，容器必须跑在 pod 中

6. 至此，一个 Nginx 服务就运行了，如果需要访问 Nginx，就需要通过 kube-proxy 来对 pod 产生访问的代理

    这样，外界的用户就可以访问集群中的 nginx 服务了。

## 四、Kubernetes 概念

**Master**：集群控制节点，每个集群需要至少一个 master 节点负责集群的管控

**Node**：工作负载节点，由 master 分配容器到这些 node 工作节点上，然后 node 节点上的 docker 负责容器的运行

**Pod**：kubernetes 的最小控制单元，容器都是运行在 pod 中的，一个 pod 中可以有 1 个或者多个容器

**Controller**：控制器，通过它来实现对 pod 的管理，比如启动 pod、停止 pod、伸缩 pod 的数量等等

**Service**：pod 对外服务的统一入口，下面可以维护同一类的多个 pod

**Label**：标签，用于对 pod 进行分类，同一类 pod 会拥有相同的标签

**NameSpace**：命名空间，用来隔离 pod 的运行环境

![image-20230908211247552](https://study-node-md.oss-cn-beijing.aliyuncs.com/2023%2F09%2F08%2F1694178768-7fc64cd69cabada2fe06851407ad48f2-image-20230908211247552.png)









