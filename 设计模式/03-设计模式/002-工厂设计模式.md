### 1、简单工厂模式

#### 1.1 看一个具体的需求

看一个披萨的项目：要便于披萨种类的扩展，要便于维护

1）披萨的种类很多（比如 GreekPizza、CheesePizza 等）

2）披萨的制作有 prepare，bake，cut，box

3）完成披萨店订购功能

#### 1.2 使用传统的方式来完成

1）思路分析（类图）

![设计模式-工厂-传统思路 UML类图](https://study-node-md.oss-cn-beijing.aliyuncs.com/2023%2F10%2F18%2F1697622997-51b2879c12ef911f5490a1195438e50b-20231018175636.png)

2）代码演示

```java
public abstract class Pizza {  
    /**  
     * 名字  
     */  
    protected String name;  
    /**  
     * 准备原材料，不同的披萨不一样，因此，我们做成抽象方法  
     */  
    public abstract void prepare();  
    /**  
     * 烘烤  
     */  
    public void bake() {  
        System.out.println(name + " baking; ");  
    }  
    /**  
     * 切割  
     */  
    public void cut() {  
        System.out.println(name + " cutting; ");  
    }  
    /**  
     * 打包  
     */  
    public void box() {  
        System.out.println(name + " boxing; ");  
    }  
    public void setName(final String name) {  
        this.name = name;  
    }  
}

public class CheesePizza extends Pizza{  
    @Override  
    public void prepare() {  
        System.out.println("给制作奶酪披萨准备原材料");  
    }  
}

public class GreekPizza extends Pizza{  
    @Override  
    public void prepare() {  
        System.out.println("给制作希腊披萨准备原材料");  
    }  
}

public class OrderPizza {  
    /**  
     * 构造器  
     */  
    public OrderPizza() {  
        Pizza pizza = null;  
        // 订购披萨的类型  
        String orderType;  
  
        do {  
            orderType = getType();  
            if ("greek".equals(orderType)) {  
                pizza = new GreekPizza();  
                pizza.setName("希腊披萨");  
            } else if ("cheese".equals(orderType)) {  
                pizza = new CheesePizza();  
                pizza.setName("奶酪披萨");  
            } else {  
                break;  
            }  
            // 输出披萨制作过程  
            pizza.prepare();  
            pizza.bake();  
            pizza.cut();  
            pizza.box();  
        } while (true);  
    }  
  
    /**  
     * 可以获取客户希望订购的披萨种类  
     */  
    private String getType() {  
        try {  
            final BufferedReader strIn = new BufferedReader(new InputStreamReader(System.in));  
            System.out.println("input pizza type: ");  
            final String str = strIn.readLine();  
            return str;  
        } catch (IOException e) {  
            e.printStackTrace();  
            return "";  
        }  
    }  
}

public class PizzaStore {  
    public static void main(String[] args) {  
        new OrderPizza();  
    }  
}
```

#### 1.3 传统的方式的优缺点

1）优点是比较好理解，简单易操作。

2）缺点是违反了设计模式的 OCP 原则，即对扩展开发，对修改关闭。即当我们给类增加新功能的时候，尽量不修改代码，或者尽可能少修改代码。

3）比如我们这时要新增加一个 Pizza 的种类（Pepper 披萨），我们需要做如下修改。

- 新增 PeeperPizza 类
- 在 OrderPizza 中新增 else-if 判断

```java
public class PepperPizza extends Pizza {  
    @Override  
    public void prepare() {  
        System.out.println("给制作胡椒披萨准备原材料");  
    }  
}

public class OrderPizza {  
    /**  
     * 构造器  
     */  
    public OrderPizza() {  
        Pizza pizza = null;  
        // 订购披萨的类型  
        String orderType;  
  
        do {  
            orderType = getType();  
            if ("greek".equals(orderType)) {  
                pizza = new GreekPizza();  
                pizza.setName("希腊披萨");  
            } else if ("cheese".equals(orderType)) {  
                pizza = new CheesePizza();  
                pizza.setName("奶酪披萨");  
            } else if ("pepper".equals(orderType)) {  
                pizza = new PepperPizza();  
                pizza.setName("胡椒披萨");  
            } else {  
                break;  
            }  
            // 输出披萨制作过程  
            pizza.prepare();  
            pizza.bake();  
            pizza.cut();  
            pizza.box();  
        } while (true);  
    }  
  
    /**  
     * 可以获取客户希望订购的披萨种类  
     */  
    private String getType() {  
        try {  
            final BufferedReader strIn = new BufferedReader(new InputStreamReader(System.in));  
            System.out.println("input pizza type: ");  
            final String str = strIn.readLine();  
            return str;  
        } catch (IOException e) {  
            e.printStackTrace();  
            return "";  
        }  
    }  
}
```

4）改进的思路分析

**分析**：修改代码可以接受，但是如果我们在其他的地方也有创建 Pizza 的代码，就意味着，也需要修改，而创建 Pizza 的代码，往往有多处。

**思路**：把创建 Pizza 对象封装到一个类中，这样我们有新的 Pizza 种类时，只需要修改该类即可，**其他有创建到 Pizza 对象的代码就不需要修改了**。-> 简单工厂模式

#### 1.4 基本介绍

1）简单工厂模式是属于创建型模式，也叫做**静态工厂模式**，是工厂模式的一种。简单工厂模式是由一个工厂对象决定创建处哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式。

2）简单工厂模式：定义了一个创建对象的类，由这个类来封装实例化对象的行为（代码）。

3）在软件开发中，当我们会用到大量的创建某种、某类或者某批对象时，就会使用到工厂模式。

#### 1.5 使用简单工厂模式

1）简单工厂模式的设计方案：定义一个可以实例化 Pizza 对象的类，封装创建对象的代码。

![设计模式-工厂模式-简单工厂模式-披萨店](https://study-node-md.oss-cn-beijing.aliyuncs.com/2023%2F10%2F18%2F1697625934-d90f850b2f79d381d281204e1920a9a2-20231018184532.png)

2）代码示例：

```java
public abstract class Pizza {  
    protected String name;  
  
    public abstract void prepare();  
  
    public void bake() {  
        System.out.println(name + " baking; ");  
    }  
  
    public void cut() {  
        System.out.println(name + " cutting; ");  
    }  
  
    public void box() {  
        System.out.println(name + " boxing; ");  
    }  
  
    public void setName(final String name) {  
        this.name = name;  
    }  
}

public class CheesePizza extends Pizza{  
    @Override  
    public void prepare() {  
        System.out.println("给制作奶酪披萨准备原材料");  
    }  
}

public class GreekPizza extends Pizza{  
    @Override  
    public void prepare() {  
        System.out.println("给制作希腊披萨准备原材料");  
    }  
}

public class PepperPizza extends Pizza{  
    @Override  
    public void prepare() {  
        System.out.println("给制作胡椒披萨准备原材料");  
    }  
}

public class SimpleFactory {  
    public Pizza createPizza(String orderType) {  
        Pizza pizza = null;  
        if ("greek".equals(orderType)) {  
            pizza = new GreekPizza();  
            pizza.setName("希腊披萨");  
        } else if ("cheese".equals(orderType)) {  
            pizza = new CheesePizza();  
            pizza.setName("奶酪披萨");  
        } else if ("pepper".equals(orderType)) {  
            pizza = new PepperPizza();  
            pizza.setName("胡椒披萨");  
        }  
        return pizza;  
    }  
  
    public static Pizza createPizza2(String orderType) {  
        Pizza pizza = null;  
        if ("greek".equals(orderType)) {  
            pizza = new GreekPizza();  
            pizza.setName("希腊披萨");  
        } else if ("cheese".equals(orderType)) {  
            pizza = new CheesePizza();  
            pizza.setName("奶酪披萨");  
        } else if ("pepper".equals(orderType)) {  
            pizza = new PepperPizza();  
            pizza.setName("胡椒披萨");  
        }  
        return pizza;  
    }  
}

public class OrderPizza {  
  
    // 定义一个简单工厂对象  
    SimpleFactory simpleFactory;  
    Pizza pizza = null;  
  
    public OrderPizza(SimpleFactory simpleFactory) {  
        setSimpleFactory(simpleFactory);  
    }  
  
    public void setSimpleFactory(final SimpleFactory simpleFactory) {  
        this.simpleFactory = simpleFactory;  
  
        String orderType = "";  
  
        do {  
            orderType = getType();  
            pizza = this.simpleFactory.createPizza(orderType);  
            // 输出pizza  
            if (pizza != null) {  
                pizza.prepare();  
                pizza.bake();  
                pizza.cut();  
                pizza.box();  
            } else {  
                System.out.println("订购披萨失败");  
                break;  
            }  
        } while (true);  
    }  
  
    /**  
     * 获取披萨类型  
     *  
     * @return  
     */  
    private String getType() {  
        try {  
            final BufferedReader strIn = new BufferedReader(new InputStreamReader(System.in));  
            System.out.println("input pizza type: ");  
            final String str = strIn.readLine();  
            return str;  
        } catch (IOException e) {  
            e.printStackTrace();  
            return "";  
        }  
    }  
}

public class OrderPizza2 {  
  
    Pizza pizza = null;  
    String orderType = "";  
  
    public OrderPizza2() {  
        do {  
            orderType = getType();  
            pizza = SimpleFactory.createPizza2(orderType);  
            // 输出pizza  
            if (pizza != null) {  
                pizza.prepare();  
                pizza.bake();  
                pizza.cut();  
                pizza.box();  
            } else {  
                System.out.println("订购披萨失败");  
                break;  
            }  
        } while (true);  
    }  
  
    private String getType() {  
        try {  
            final BufferedReader strIn = new BufferedReader(new InputStreamReader(System.in));  
            System.out.println("input pizza type: ");  
            final String str = strIn.readLine();  
            return str;  
        } catch (IOException e) {  
            e.printStackTrace();  
            return "";  
        }  
    }  
}

public class PizzaStore {  
    public static void main(String[] args) {  
        // 使用简单工厂模式  
        // new OrderPizza(new SimpleFactory());  
  
        // 静态工厂模式  
        new OrderPizza2();  
    }  
}
```

### 2、工厂方法模式